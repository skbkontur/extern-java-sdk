# SDK для работы с API Контур.Экстерна для платформы JVM

[TOC]

## 1. Назначение
Предназначен для легкой интеграции внешних систем с [API Контур.Экстерна](https://github.com/skbkontur/extern-api-docs), разработанных для платформы **JVM**. Для этого библиотека предоставляет класс *ExternEngine*, с помощью которого производится передача данных на внешние сервисы СКБ Контур.

## 2. Подключение SDK к проекту

### Указать библиотеку как зависимость из [maven.central](https://mvnrepository.com/artifact/ru.kontur.extern-api/extern-api-java-sdk):
```xml
<dependency>
    <groupId>ru.kontur.extern-api</groupId>
    <artifactId>extern-api-java-sdk</artifactId>
    <version>${extern-api-java-sdk.version}</version>
</dependency>
```

### Компиляция из исходного кода:

1. Склонировать репозиторий SDK:
    ```cmd
    git clone git@github.com:skbkontur/extern-java-sdk.git
    ```
    
1. Собрать и установить проект в локальный maven репозиторий:
    ```cmd
    mvn clean install
    ```
    
1. Добавить в `pom.xml` проекта артефакт `extern-api-java-sdk`:
    ```xml
    <dependency>
        <groupId>ru.kontur.extern-api</groupId>
        <artifactId>extern-api-java-sdk</artifactId>
        <version>${extern-api-java-sdk.version}</version>
    </dependency>
    ```

## 3. Конфигурирование
Для того чтобы начать работу с **SDK**, необходимо создать и сконфигурировать объект *ExternEngine*. Для конфигурации необходимо создать и передать с помощью соответствующего сеттера следующие провайдеры:

- **ServiceBaseUriProvider** – предоставляет адрес сервиса в Интернет. Провайдер представляет из себя объект, имплементирующий метод getServiceBaseUri интерфейса ServiceBaseUriProvider, возвращающий URI сервиса. В простейшем случае вы можете передать лямбда-выражение типа: ()->”https://...”;
- **AccountProvider** — предоставляет идентификатор аккаунта, который передается при отправки данных на сервис. Данный идентификатор связан с лицевым счетом в системе СКБ Контур. Провайдер представляет из себя объект, имплементирующий метод *accountId* интерфейса *AccountProvider*. В простейшем случае вы можете передать лямбда-выражение типа:     ()->UUID.fromString("XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX");
- <a name="apiKey">**ApiKeyProvider**</a> – предоставляет идентификатор, который выдается сервису, от которого отправляются запросы к API СКБ Контура. Провайдер представляет из себя объект, имплементирующий метод getApiKey интерфейса ApiKeyProvider. Также может из себя представлять лямбда-выражение типа:     ()->"XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX";
- **CryptoProvider** – предоставляет криптографический провайдер. В SDK есть три реализации:  
  - реализация для работы с [MSCapi](https://msdn.microsoft.com/en-us/library/windows/desktop/aa380256.aspx) - класс *CryptoProviderMSCap*;
  - реализация для работы с облачными сертификатами Удостоверяющего Центра СКБ Контур - класс *CloudCryptoProvider*;
  - реализация для RSA-криптографии *CryptoProviderRSA*.

    Первая (MSCAPI) и вторая (облачная) реализации криптографии предназначены для вычисления электронной подписи и расшифрования зашифрованных документов, с использованием алгоритмов ГОСТ. Третья (RSA) предназначена для подписания идентификационных данных для доверительной аутентификации, с использованием алгоритмов RSA.  

	В некоторых случаях может появиться потребность разработать свою реализацию криптопровайдера. В частности это может потребоваться, когда криптографические операции должны выполняться на удаленной машине, например на машине клиента. В таком случае криптопровайдер должен фунционировать в режиме прокси. Для этого необходимо реализовать класс, имплементирующий интерфейс **CryptoProvider**. 

- **AuthenticationProvider** — предоставляет аутентификатор. Каждый запрос, отправляемый к сервисам СКБ Контур, должен сопровождаться идентификатором аутентификационной сессии. Аутентифицироваться можно:
   * по логину и паролю, для этого в SDK есть класс AuthenticationProviderByPass, реализующий интерфейс *AuthenticationProvider*;
   * с помощью механизмов доверительной аутентификации, для этого в SDK реализован класс *TrustedAuthentication*, так-же реализующий интерфейс *AuthenticationProvider*;
   * с помощью сертификата личного ключа, для этого в SDK предназначен класс *CertificateAuthenticationProvider*, реализующий интерфейс *AuthenticationProvider*.  

- **UserIPProvider** - предоставляет IPV4 адрес компьютера отправителя. По умолчанию в *ExternEngine* будет установлен провайдер, который возвращает IP адрес локального компьютера. Для замены провайдера необходимо воспользоваться методом **`ExternEngine.setUserIPProvider`**. При отправке черновика Контур Экстерн производит валидацию значения IP адреса. IP адрес не должен быть локальным, см. [RFC 5735](https://tools.ietf.org/html/rfc5735#page-6). 

### 3.1. <a name="cryptoProvider">Конфигурирование криптопровайдеров</a>

#### 3.1.1. <a name="mscapi">MSCAPI криптопровайдер</a>
##### Назначение
Предназначен для выполнения криптографических операций на компьютере клиента с помощью сертифицированного криптопровайдера с использованием **ГОСТ**-алгоритмов, например **КриптоПро**. Для расшифрования и вычисления электронной подписи требуется доступный ключевой носитель, содержащий сертификат открытого ключа.
##### Создание и конфигурирование
Для создания объекта достаточно вызвать конструктор класса *CryptoProviderMSCapi*. Дальнейшее конфигурирование не требуется.

#### 3.1.2. <a name="cloudcapi">Облачный криптопровайдер</a>
##### Назначение
Предназначен для выполнения криптографических операций на сервере с использованием **ГОСТ**-алгоритмов. Клиент делегирует выполнение криптографических операций специальному сервису.

Криптографические операции: вычисление подписи и расшифрование выполняются в два этапа:

- 1 этап – это запрос на выполнение операции;
- 2 этап – подтверждение операции СМС–кодом.

На первом этапе сервис принимает запрос и возвращает идентификатор запроса. На втором этапе сервис ожидает идентификатор запроса, который был отдан, и СМС-код.
##### Создание и конфигурация
Для работы с облачной криптографией необходимо создать объект *CloudCryptoProvider* с помощью конструктора, передав в него, адрес  облачного сервиса. Для полученного объекта необходимо установить:
   * *AuthenticationProvider* – провайдер для получения токена аутентификации. Назначение аутентификации и типы были описаны выше.
   * *ApiKeyProvider* – провайдер для получения идентификатора сервиса. [Описание см. выше](#apiKey).
   * *CertificateProvider* – провайдер предназначен для получения сертификата отправителя в DER-кодировке по его отпечатку из внутреннего хранилища внешней системы. Данный провайдер должен имплементировать интерфейс типа: *CertificateProvider*, реализующий метод  `QueryContext<byte[]> getCertificate(String thumbprint)`, где thumbprint - отпечаток сертификата. Метод возвращает контекст типа: QueryContext<byte[]>. Контекст должен содержащий сертификат или ошибку, в зависимости от возвращаемого результата метода isFail. Если метод isFail возвращает значение false, то метод getResult вернет массив байт сертификата, иначе метод getServiceError вернет ошибку;
   * *ApproveCodeProvider* – провайдер предназначен для получения СМС-кода, который отправляется облачным сервисом на зарегистрированный номер телефона отправителя. Данный провайдер должен имплементировать интерфейс типа: `Function<String, String>`, где параметром является идентификатор запроса, а возвращаемым значением – СМС-код.

#### 3.1.3. RSA криптопровайдер
##### Назначение
Предназначен для вычисления электронной подписи с использованием **RSA**-алгоритмов. Данный криптопровайдер может быть использован для доверительной аутентификации.
##### Создание и конфигурация
Для работы с **RSA** подписью необходимо создать объект типа *CryptoProviderRSA* с помощью конструктора. Конструктор принимает на вход пароль для ключевого хранилища **JAVA** (**JKS**) и пароль для секретного ключа. Если в качестве паролей передать значение **null**, то это будет означать его отсутствие.  Для полученного объекта можно установить провайдер *KeyStoreProvider* типа **`Supplier<String>`**, который возвращает путь к **JKS**. По умолчанию криптопровайдер использует **java runtime JKS**: `System.getProperty("java.home")+File.separator+"lib"+File.separator+"security"+File.separator+"cacerts"`.

### 3.2. Конфигурирование аутентификаторов

#### 3.2.1.  Аутентификация по логину и паролю
Для аутентификации по логину и паролю необходимо создать объект класса AuthenticationProviderByPass с помощью конструктора. Конструктор принимает четыре параметра:
- *authBaseUriProvider* : *UriProvider* – URI провайдер, возвращает адрес сервиса аутентификации. В простейшем случае можно использовать лямбда-выражение: `()->"https://...”`;
- *loginAndPasswordProvider* : *LoginAndPasswordProvider* – объект, реализующий соответствующий интерфейс, возвращающий логин и пароль пользователя из внешней системы;
- *apiKeyProvider* : *ApiKeyProvider*. [Описание см. выше](#apiKey).

#### 3.2.2.  Доверительная аутентификация
Для доверительной аутентификации необходимо создать объект класса *TrustedAuthentication* с помощью конструктора.  Для полученного объекта с помощью соответствующих сеттеров необходимо установить следующие провайдеры:
- *ApiKeyProvider* – провайдер для получения идентификатора организации. [Описание см. выше.](#apiKey)
- *authBaseUriProvider* : *UriProvider* – **URI** провайдер, возвращает адрес сервиса аутентификации. В простейшем случае можно использовать лямбда-выражение: `()->"https://...”`;
- *CryptoProvider* – предоставляет криптографический провайдер. Можно установить либо **MSCAPI** провайдер, либо **RSA** криптопровайдер. Для того чтобы можно доверительно аутентифицироваться, необходимо зарегистрировать сертификат в сервисе доверительной аутентификации. Для этого необходимо обратиться в СКБ Контур.
- *SignatureKeyProvider* – предоставляет отпечаток сертификата ключа, с помощью которого будут подписываться идентификационный данные конечного пользователя (отправителя). В простейшем случае можно использовать лямбда-выражение: `()->”XXXXXXXXXXXXXXXXXXXX”`;
- *ServiceUserIdProvider* – предоставляет идентификатор конечного пользователя во внешней системе. В простейшем случае можно использовать лямбда-выражение: `()->”XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX”`;
- *CredentialProvider* – предоставляет структуру данных содержащий наименования идентификатора, идентифицирующий пользователя, и его значение. В простейшем случае можно использовать лямбда-выражение:` ()->new Credential(”phone”,”03”)`. В качестве идентификатора пользователя можно использовать:  
  - номер телефона (phone);
  - СНИЛС (snils);
  - идентификатор пользователя (serviceUserId):
  - отпечаток сертификата пользователя (thumbprint);
  - логин пользователя (login).

#### 3.2.3.  Аутентификация по сертификату
Аутентификация по сертификату проходит по следующей схеме:
* клиент выполняет запрос на сервис аутентификации. При этом он пересылает сертификат закрытого ключа;
* сервис, получив запрос, выполняет проверку регистрации полученного от клиента сертификата;
* в случае успешной проверки сервис возвращает зашифрованный контент на переданном сертификате;
* клиент расшифровывает зашифрованный контент своим личным ключом, полученный от сервиса аутентификации, и отправляет на сервис аутентификации;
* сервис аутентификации проверяет результат, и в случае успеха возвращает клиенту токен аутентификации для доступа к сервисам.

[Подробнее можно ознакомиться здесь.](https://github.com/skbkontur/extern-api-docs/blob/master/%D0%90%D1%83%D1%82%D0%B5%D0%BD%D1%82%D0%B8%D1%84%D0%B8%D0%BA%D0%B0%D1%86%D0%B8%D1%8F.md#1)
   
Для аутентификации по сертификату необходимо создать провайдер типа *CertificateAuthenticationProvider* и установить его в экземпляр класса *ExternEngine*. Чтобы создать провайдер необходимо выполнить следующие шаги:
* вызвать статический метод *usingCertificate* класса *CertificateAuthenticationProvider* и передать ему следующие параметры:
  * *certificateProvider*: *CertificateProvider* -  объект, реализующий метод `QueryContext<byte[]> getCertificate(String thumbprint)`. Метод должен принимать параметр отпечаток сертификата, а возвращать контекст с сертификатом в DER-кодировке или ошибку, в зависимости от возвращаемого результата метода `isFail`. Метод `isFail` вернет значение `true`, если в контекст будет установлена ошибка с помощью одного из методов `setServiceError`;
  * *skipCertValidation*: *boolean* - необязательный параметр, задающий режим отмены валидации сертификата. Если параметр не задан, то сертификат будет проходить процедуру валидации.

  Данный метод вернет билдер *CertificateAuthenticationProviderBuilder*;

* в полученный билдер с помощью соответствующих методов необходимо установить следующие провайдеры:
  * *ApiKeyProvider* - провайдер для получения идентификатора сервиса. [Описание см. выше](#apiKey);
  * *CryptoProvider* - реализацию криптографического провайдера. Аутентификация по сертификату использует только одну криптографическую операцию - расшифрование. В связи с этим, объект, реализующий интерфейс *CryptoProvider*, должен реализовать только метод расшифрования `QueryContext<byte[]> decrypt(QueryContext<byte[]> cxt)`. В реализациях приняты следующие соглашения. Передаваемый контекст должен содержать отпечаток сертификата, установленный с помощью метода `setThumbprint`, и зашифрованный  контент в формате PKCS#7, установленный с помощью метода `setContent`. Метод должен возвращать контекст, содержащий массив байт расшифрованного контента, установленный с помощью метода `setResult(<decrypted content>,CONTENT)`. Если аутентификация по сертификату используется в сервисе, то реализация `CryptoProvider` должна быть выполнена в режиме прокси, т.е. для расшифрования зашифрованный контент необходимо переслать конечному пользователю. Для "толстого" клиента можно использовать реализацию [`CryptoProviderMSCapi`](#mscapi) или [`CloudCryptoProvider`](#cloudcapi);
  * *ServiceBaseUriProvider* - провайдер, возвращающий адрес сервиса аутентификации в Интернет. В простейшем случае вы можете передать лямбда-выражение типа: `()->”https://..."`;
  * *SignatureKeyProvider* - провайдер, предоставляющий отпечаток сертификата личного ключа. В простейшем случае можно использовать лямда-выражение: ()->"XXXXXXXXXXXXXXXXXXXX".

## 4. Архитектура
В SDK реализован класс **ru.kontur.extern_api.sdk.ExternEngine**, обеспечивающий доступ к операциям Контур Экстерн. Все операции разделены на следующие группы:

- сервис для работы с учетными записями конечных пользователей (**AccoutService**);
- сервис для получения информации о сертификатах конечных пользователей (**CertificateService**);
- сервис для работы со списком организаций (**OrganizationService**);
- сервис для работы с черновиками (**DraftService**);
- сервис для работы с документооборотами (**DocflowService**);
- сервис для работы с лентой событий (**EventService**).

Для получения доступа к сервису необходимо у объекта ExternEngine вызвать соответствующий метод типа **get<имя сервиса>**. Например для того чтобы получить доступ к операциям сервиса для работы с учетными записями необходимо использовать метод **getAccoutService()**, который вернет экземпляр класса, реализующий интерфейс **AccoutService**. Каждая операция сервиса имеет две реализации: асинхронную, имеющую суффикс **Async** и синхронную, которая этого суффикса не имеет. Асинхронная операция возвращает объект типа **CompletableFuture<QueryContext<...>>**, а синхронная возвращает объект типа **QueryContext<...>**. Класс **QueryContext** содержит как входные параметры для синхронных операций, так и результат выполненной операции. В свою очередь результат одной операции может являться входным параметром для следующей операции в цепочке вызовов. Такой подход позволяет реализовывать бизнес задачи с использованием парадигмы **FORK & JOIN**.  

Для примера в **SDK** был реализован высокоуровневый метод отправки документов в налоговую инспекцию: **BusinessDriver.sendDocument**. Данный метод в качестве параметров получает массив отправляемых файлов (декларация может состоять из нескольких файлов плюс доверенность, если используется схема посредника), информацию об отправителе, информацию о получателе и информацию об организации, за которую производится отправка. В начале цепочки выполняется асинхронная операция создания черновика. Данная операция получает входные параметры, а возвращает объект `CompletableFuture<QueryContext<UUID>>`. Далее для каждого файла асинхронно последовательно выполняются две операции: вычисление подписи (ЭП) и загрузка документа вместе с ЭП в черновик, с помощью метода **CompletableFuture.thenCombine**. На следующем шаге программа ожидает выполнение всех асинхронных операций, используя метода **CompletableFuture.allOf** . По завершению (см. метод  **join** ) последовательно выполняются операции: подготовки к отправке и отправка документов. Каждая операция производит проверку контекста (**QueryContext**) на наличие ошибки с помощью метода **isFail**. В случае обнаружения ошибки цепочка прерывается. После выполнения цепочки операций необходимо проверить контекст на наличие ошибки. Если ошибка отсутствует, то все операции завершились успешно, иначе метод **getServiceError** вернет ошибку последней операции.
  
Класс **QueryContext** содержит коллекцию типа **Map**, для сохранения входных и выходных параметров. Для каждого используемого параметра существует свой сеттер, например, для установки передаваемого контента есть метод **setContent**. Как уже упоминалось выше, метод **isFail** возвращает признак операции, завершившейся с ошибкой. В этом случае метод **getServiceError** вернет ошибку. Если операции выполнилась успешно, то метод **isSuccess** вернет истину, а метод **get** результат операции, который указан в качестве параметра класса **QueryContext**. Более подробное описание смотри в **javadoc**.

### 4.1. Сервис для работа с учетными записями  
  
#### 4.1.1. Методы для получения списка учетных запись  

  - `CompletableFuture<QueryContext<AccountList>> acquireAccountsAsync()`;  

  - `QueryContext<AccountList> acquireAccounts(QueryContext<?> cxt)`.  
  
Методы вернут структуру данных **AccountList** со списком учетных записей **Account** для одной страницы. Описание см. ниже.  

#### 4.1.2. Методы для создания новой учетной записи  

- `CompletableFuture<QueryContext<Account>> createAccountAsync(CreateAccountRequest createAccountRequest)`  
Параметры:      
  - createAccountRequest - структура данных CreateAccountRequest, которая содержит следующие данные:
  - ИНН;
  - КПП;  
  - наименование организации.  
- `QueryContext<Account> createAccount(QueryContext<?> cxt)`  
    Должен принимать параметр **QueryContext**, содержащий структуру данных CreateAccountRequest, установленую с помощью метода **setCreateAccountRequest**.  

Методы вернут структуру **Account** со следующими параметрами:  

+ идентификатор записи;  
+ ИНН;  
+ КПП;  
+ наименование организации;
+ список ссылок на сервисы для учетной записи.  

### 4.2. Сервис для получения списка сертификатов
  
#### 4.2.1. Методы для получения списка сертификатов
  
- `CompletableFuture<QueryContext<CertificateList>> getCertificateListAsync()`  
  
- `QueryContext<CertificateList> getCertificateList(QueryContext<?> parent)`  

Методы возвращают структуру данных **CertificateList**, содержащая список сертификатов со следующими данными:

- ФИО;  
- ИНН;  
- КПП;  
- признак валидности сертификата;  
- признак облачного сертификата;  
- признак квалифицированного сертификата;  
- сертификат в кодировке BASE64.
 
### 4.3. Сервис для работы со списком организаций  

#### 4.3.1. Методы для поиска организации по идентификатору  

- `CompletableFuture<QueryContext<Company>> lookupAsync(String companyId)`  
Параметры:
  - идентификатор организации.  
- `QueryContext<Company> lookup(QueryContext<?> cxt)`  
Должен принимать параметр **QueryContext**, содержащий идентификатор организации, установленый с помощью метода **setCompanyId**.  

Методы возвращают структуру **Company** со следующими данными:

- идентификатор организации;  
- ИНН;  
- КПП;  
- имя организации.  

#### 4.3.2. Методы для создания новой организации  

- `CompletableFuture<QueryContext<Company>> createAsync(CompanyGeneral companyGeneral)`  
Параметры:  
  - companyGeneral - **CompanyGeneral** содержит следующие данные:
    - ИНН;
    - КПП;
    - имя организации.  
- `QueryContext<Company> create(QueryContext<?> cxt)`  
    Должен принимать параметр **QueryContext**, содержащий структуру данных **CompanyGeneral**, установленную с помощью метода **setCompanyGeneral**.  
  
Методы возвращают структуру **Company**, описанную выше.  

#### 4.3.3. Методы для обновления данных существующей организации:
  
- `CompletableFuture<QueryContext<Company>> updateAsync(String companyId, String name)`  
Параметры:
  - идентификатор организации;  
  - имя организации.  
- `QueryContext<Company> update(QueryContext<?> cxt)`  
Должен принимать параметр **QueryContext**, содержащий следующие данные:
  - идентификатор организации, установленный с помощью метода **setCompanyId**;
  - наименование организации, установленный с помощью метода **setName**.  
 
Методы возвращают структуру **Company**, описанную выше.  

#### 4.3.4. Методы для удаления существующей организации:  

- `CompletableFuture<QueryContext<Void>> deleteAsync(String companyId)`  
Параметры:  
	- идентификатор организации.    
- `QueryContext<Void> delete(QueryContext<?> cxt)`  
Должен принимать параметр **QueryContext**, содержащий следующие данные:  
	- идентификатор организации, установленный с помощью метода **setCompanyId**.  

#### 4.3.5. Методы для поиска организации по ИНН и КПП:  

- `CompletableFuture<QueryContext<CompanyBatch>> searchAsync(String inn, String kpp, Long skip, Integer take)`  
Параметры:  
  - ИНН;
  - КПП;
  - skip - смещение от начала списка;
  - take - максимальное количество возвращаемых записей с организациями.  
- `QueryContext<CompanyBatch> search(QueryContext<?> cxt)`  
Должен принимать параметр **QueryContext**, содержащий следующие данные:  
  - ИНН, для установки необходимо использовать метод **setInn**;  
  - КПП, для установки необходимо использовать метод **setKpp**;
  - skip - смещение от начала списка, для установки необходимо использовать метод **setSkip**;
  - take - максимальное количество возвращаемых организаций, для установки необходимо использовать метод **setTake**.  
  
Методы возвращают структуру данных **CompanyBatch**, содержащую список организации **Company**, которая была описана выше.  

### 4.4. Сервис для работы с черновиками  

#### 4.4.1. Методы для создания черновика  

- `CompletableFuture<QueryContext<UUID>> createAsync(Sender sender, Recipient recipient, Organization organization)`  
Параметры:  
  - sender - отправитель. Включает в себя следующие данные:  
  - ИНН;  
  - КПП;  
  - сертификат подписи отправителя в кодировке BASE64 без тегов;  
  - отпечаток сертификата подписи отправителя;  
  - IP адрес отправителя.  
  - recipient - получатель. Существуют следующие типы получателей:  
    - класс FnsRecipient - для отправки документов в ФНС. Содержит код ФНС;  
    - класс TogsRecipient - для отправки документов в Росстат. Содержит код территориального отделения государственной статистики.  
  - organization - организация, за которую производится отправка документов. Включает в себя следующую информацию:    
      - ИНН;
      - КПП.  
- `QueryContext<UUID> create(QueryContext<?> cxt)`  
Должен принимать параметр **QueryContext**, содержащий следующие данные:  
  - информация о черновике - экземпляр класс **DraftMeta**, который можно получить с помощью конструктора `DraftMeta(Sender sender, Recipient recipient, Organization organization)`. Для установки в контекст необходимо использовать метод **setDraftMeta**.    
  
Методы возвращают идентификатор созданного черновика.  

#### 4.4.2. Методы для поиска черновика по идентификатору
- `CompletableFuture<QueryContext<Draft>> lookupAsync(String draftId)`    
Параметры:
  - идентификатор черновика.  
- `QueryContext<Draft> lookup(QueryContext<?> cxt)`  
Должен принимать параметр **QueryContext**, содержащий следующие данные:
  - идентификатор черновика. Для установки необходимо использовать метод **setDraftId**.  

Методы возвращают структуру данных **Draft**, включающую в себя следующие данные:
  
- идентификатор черновика;  
- список ссылок на документы черновика;  
- структура данных DraftMeta. Включает в себя отправителя, получателя и организацию, за которую производится отправка;  
- статус черновика:
  - new - новый, устанавливается после создания черновика;  
  - checked - проверенный, устанавливается после вызова метода проверки черновика;   
  - readyToSend - готов к отправке, устанавливается после вызова метода подготовки черновика к отпрвке;  
  - sent - послан, устанвливается после вызова метода отправки черновика.  
- список ссылок, связанных с черновиком;  
- список ссылок, связанных с документооборотами.  

#### 4.4.3. Методы для удаления черновика
  
- `CompletableFuture<QueryContext<Void>> deleteAsync(String draftId)`  
Параметры:  
  - идентификатор черновика.  
  
- `QueryContext<Void> delete(QueryContext<?> cxt)`  
Должен принимать параметр **QueryContext**, содержащий следующие данные:
  - идентификатор черновика. Для установки необходимо использовать метод **setDraftId**.  

#### 4.4.4. Методы для получения структуры данных DaftMeta
  
- `CompletableFuture<QueryContext<DraftMeta>> lookupDraftMetaAsync(String draftId)`  
Параметры:  
  - идентификатор черновика.
 
- `QueryContext<DraftMeta> lookupDraftMeta(QueryContext<?> cxt)`  
Должен принимать параметр **QueryContext**, содержащий следующие данные:
  - идентификатор черновика. Для установки необходимо использовать метод **setDraftId**.  

Методы возвращают структуру данных DraftMeta, описанную выше.

#### 4.4.5. Методы для обновления структуры данных **DaftMeta**

- `CompletableFuture<QueryContext<DraftMeta>> updateDraftMetaAsync(String draftId, DraftMeta draftMeta)`  
Параметры:  
  - идентификатор черновика;
  - draftMeta - информация о черновике (описание см. выше).  
- `QueryContext<DraftMeta> updateDraftMeta(QueryContext<?> cxt)`  
Должен принимать параметр **QueryContext**, содержащий следующие данные:  
  - идентификатор черновика. Для установки необходимо использовать метод **setDraftId**;  
  - информацию о черновике. Для  установки необходимо использовать метод **setDraftMeta**.  

Методы возвращают структуру данных DraftMeta, описанную выше.

#### 4.4.6. Методы для проверки черновика перед отправкой
  
- `CompletableFuture<QueryContext<Map<String, Object>>> checkAsync(String draftId)`
Параметры:  
- идентификатор черновика.  
- `QueryContext<Map<String, Object>> check(QueryContext<?> cxt)`  
Должен принимать параметр **QueryContext**, содержащий следующие данные:  
  - идентификатор черновика. Для установки необходимо использовать метод **setDraftId**.  

Методы возвращают структуру данных типа **Map**, которая содержит описание ошибок. 

#### 4.4.7. Методы подготовки черновика к отправке  

Методы производят шифрование документов на сертификатах отправителя и получателя.  
  
- `CompletableFuture<QueryContext<PrepareResult>> prepareAsync(String draftId)`  
Параметры:  
  - идентификатор черновика.  
- `QueryContext<PrepareResult> prepare(QueryContext<?> cxt)`  
Должен принимать параметр **QueryContext**, содержащий следующие данные:
  - идентификатор черновика. Для установки необходимо использовать метод **setDraftId**.  
 
Методы возвращают структуру данных типа **PrepareResult**, которая содержит описание ошибок.
 
#### 4.4.8.  Методы для отправки черновика 
  
- `CompletableFuture<QueryContext<List<Docflow>>> sendAsync(String draftId)`  
Параметры:  
  - идентификатор черновика.  
- `QueryContext<List<Docflow>> send(QueryContext<?> cxt)`  
Должен принимать параметр **QueryContext**, содержащий следующие данные:
  - идентификатор черновика. Для установки необходимо использовать метод **setDraftId**.  
  
Методы возвращают список данных типа **Docflow**.

#### 4.4.9. Методы для добавления документа в черновик
  
- `CompletableFuture<QueryContext<DraftDocument>> addDecryptedDocumentAsync(UUID draftId, DocumentContents documentContents)`  
Параметры:  
  - draftId - идентификатор черновика;  
  - documentContents - информация о добавляемом документе. Содержит следующую информацию:  
      - контент в **BASE64** кодировке;  
      - подпись в формате **PKCS#7**, в кодировке **BASE64**;
      - структура данных **DocumentDescription**. Содержит следующую информацию:
      - тип документа;
      - имя файла документа;
      - тип контента. Для **XML**-документа параметр должен принимать значение **application/xml**, для **PDF**-документа - **application/pdf**.  
- `QueryContext<DraftDocument> addDecryptedDocument(QueryContext<?> cxt)`  
Должен принимать параметр **QueryContext**, содержащий следующие данные:  
  - идентификатор черновика. Для установки необходимо использовать метод **setDraftId**;  
  - контент документа. Для установки необходимо использовать метод **setDocumentContents**.  

Методы возвращают структуру данных DraftDocument, содержащая следующую информацию:  

- идентификатор документа;
- ссылка на расшифрованный контент документа;
- ссылка на зашифрованный контент документа;
- ссылка на подпись;
- структура данных **DocumentDescription** (описание см. выше).  

#### 4.4.10. Методы для поиска документа в черновике по идентификатору
  
- `CompletableFuture<QueryContext<DraftDocument>> lookupDocumentAsync(String draftId, String documentId)`  
Параметры:  
  - draftId - идентификатор черновика;  
  - documentId - идентификатор документа.  
- QueryContext<DraftDocument> lookupDocument(QueryContext<?> cxt)    
Должен принимать параметр **QueryContext**, содержащий следующие данные:  
 - идентификатор черновика. Для установки необходимо использовать метод **setDraftId**;  
  - идентификатор документа. Для установки необходимо использовать метод **setDocumentId**.  
 
Методы возвращают структуру данных DraftDocument (описание см. выше).  

#### 4.4.11. Методы для обновления документа в черновике
  
- `CompletableFuture<QueryContext<DraftDocument>> updateDocumentAsync(String draftId, String documentId, DocumentContents documentContents)`  
Параметры:  
  - draftId - идентификатор черновика;  
  - documentId - идентификатор документа;
  - documentContents - информация о добавляемом документе (описание см. выше).  
- `QueryContext<DraftDocument> updateDocument(QueryContext<?> cxt)`  
Должен принимать параметр **QueryContext**, содержащий следующие данные:  
  - идентификатор черновика. Для установки необходимо использовать метод **setDraftId**;
  - идентификатор документа. Для установки необходимо использовать метод **setDocumentId**;
  - контекст документа. Для установки необходимо использовать метод **setDocumentContents**.  

Методы возвращают структуру данных DraftDocument (описание см. выше).  

#### 4.4.12. Методы для удаления документа из черновика
  
- `CompletableFuture<QueryContext<Void>> deleteDocumentAsync(String draftId, String documentId)`  
Параметры: 
  - draftId - идентификатор черновика;  
  - documentId - идентификатор документа;    
- `QueryContext<Void> deleteDocument(QueryContext<?> cxt)`  
Должен принимать параметр **QueryContext**, содержащий следующие данные:
  - идентификатор черновика. Для установки необходимо использовать метод **setDraftId**;  
  - идентификатор документа. Для установки необходимо использовать метод **setDocumentId**.  

#### 4.4.13. Методы для получения печатной формы

- `CompletableFuture<QueryContext<String>> printDocumentAsync(String draftId, String documentId)`  
Параметры:
  - draftId - идентификатор черновика;  
  - documentId - идентификатор документа.  
- `QueryContext<String> printDocument(QueryContext<?> cxt)`  
Должен принимать параметр **QueryContext**, содержащий следующие данные:
  - идентификатор черновика. Для установки необходимо использовать метод **setDraftId**;  
  - идентификатор документа. Для установки необходимо использовать метод **setDocumentId**.  
 
Методы возвращают документ в PDF формате закодированные в BASE64.

#### 4.4.14. Методы для получения расшифрованного контента
  
- `CompletableFuture<QueryContext<String>> getDecryptedDocumentContentAsync(String draftId, String documentId)`    
Параметры:
  - draftId - идентификатор черновика;  
  - documentId - идентификатор документа.  
- `QueryContext<String> getDecryptedDocumentContent(QueryContext<?> cxt)`  
Должен принимать параметр **QueryContext**, содержащий следующие данные:  
  - идентификатор черновика. Для установки необходимо использовать метод **setDraftId**;  
  - идентификатор документа. Для установки необходимо использовать метод **setDocumentId**.  

Методы возвращают расшифрованный контент в кодировке BASE64.

#### 4.4.15. Методы для обновления расшифрованного контента
  
 - `CompletableFuture<QueryContext<Void>> updateDecryptedDocumentContentAsync(String draftId, String documentId, byte[] content)`  
Параметры:
  - draftId - идентификатор черновика;  
  - documentId = идентификатор документа;  
  - content - массив байт контента документа.  
- `QueryContext<Void> updateDecryptedDocumentContent(QueryContext<?> cxt)`  
Должен принимать параметр **QueryContext**, содержащий следующие данные:  
  - идентификатор черновика. Для установки необходимо использовать метод **setDraftId**;  
  - идентификатор документа. Для установки необходимо использовать метод **setDocumentId**.  
  - массив байт контента документа. Для установки необходимо использовать метод **setContent**.  

#### 4.4.16. Методы для получения контента подписи
  
- `CompletableFuture<QueryContext<String>> getSignatureContentAsync(String draftId, String documentId)`  
Параметры:
  - draftId - идентификатор черновика;  
  - documentId = идентификатор документа.  
- QueryContext<String> getSignatureContent(QueryContext<?> cxt)  
Должен принимать параметр **QueryContext**, содержащий следующие данные:  
  - идентификатор черновика. Для установки необходимо использовать метод **setDraftId**;  
  - идентификатор документа. Для установки необходимо использовать метод **setDocumentId**.  

Методы возвращают контент подписи в кодировке BASE64.  

#### 4.4.17. Методы для обновления контента подписи:  

- `CompletableFuture<QueryContext<Void>> updateSignatureAsync(String draftId, String documentId, byte[] content)`
Параметры:
  - draftId - идентификатор черновика;  
  - documentId = идентификатор документа;  
  - content - массив байт контента подписи.  
- `QueryContext<Void> updateSignature(QueryContext<?> cxt)`  
Должен принимать параметр **QueryContext**, содержащий следующие данные:  
  - идентификатор черновика. Для установки необходимо использовать метод **setDraftId**;  
  - идентификатор документа. Для установки необходимо использовать метод **setDocumentId**.  
  - массив байт контента документа. Для установки необходимо использовать метод **setContent**.  

#### 4.4.18. Методы для создания декларации УСН, принимающие на вход файл в формате JSON  
  
- `CompletableFuture<QueryContext<Void>> createUSN1Async(String draftId, String documentId, UsnServiceContractInfo usn)`  
Параметры:  
  - draftId - идентификатор черновика;  
  - documentId = идентификатор документа;  
  - usn - структура данных UsnServiceContractInfo, содержащая следующую информацию:  
      - period - тип периода, за который сдается декларация;  
      - additionalOrgInfo - дополнительная информация об организации;  
      - data - строка, содержащая json с данными для УСН декларации.  
- `QueryContext<Void> createUSN1(QueryContext<?> cxt)`  
Должен принимать параметр **QueryContext**, содержащий следующие данные:
  - идентификатор черновика. Для установки необходимо использовать метод **setDraftId**;  
  - идентификатор документа. Для установки необходимо использовать метод **setDocumentId**.  
  - структура данных UsnServiceContractInfo. Для установки необходимо использовать метод **setUsnServiceContractInfo**.  

#### 4.4.19. Методы для создания декларации УСН, принимающие на вход объектную модель

- `CompletableFuture<QueryContext<Void>> createUSN2Async(String draftId, String documentId, UsnServiceContractInfoV2 usn)`  
Параметры:  
  - draftId - идентификатор черновика;  
  - documentId = идентификатор документа;  
  - usn - структура данных UsnServiceContractInfoV2, содержащая информацию для УСН декларации.  
- QueryContext<Void> createUSN2(QueryContext<?> cxt)  
Должен принимать параметр **QueryContext**, содержащий следующие данные:  
  - идентификатор черновика. Для установки необходимо использовать метод **setDraftId**;  
  - идентификатор документа. Для установки необходимо использовать метод **setDocumentId**.  
  - структура данных UsnServiceContractInfoV2. Для установки необходимо использовать метод **setUsnServiceContractInfoV2**.  

### 4.5. Сервис для работы с документооборотами (ДО)

#### 4.5.1. Методы для поиска ДО по фильтру

- `CompletableFuture<QueryContext<DocflowPage>> getDocflowsAsync(boolean finished, boolean incoming, long skip, int take, String innKpp, Date updatedFrom, Date updatedTo, Date createdFrom, Date createdTo, String type)`
Параметры:  
  - finished - признак завершенных ДО. **true** - только завершенные ДО, иначе - все;
  - incoming - признак ДО, инициализируемые контролирующими органами. **true** - включать только входящие ДО, иначе - исходящие;
  - skip - смещение от начала списка ДО;
  - take - максимальное количество возвращаемых ДО;
  - innkpp - ИНН и КПП подотчетной организации;
  - updateFrom - дата обновления ДО, с которой производится поиск. Если передано значение null, то критерий не учитывается;
  - updateTo - дата обновления ДО, до которой производится поиск. Если передано значение null, то критерий не учитывается;
  - createFrom - дата создания ДО, с которой производится поиск. Если передано значение null, то критерий не учитывается;
  - createTo - дата создания ДО, до которой производится поиск. Если передано значение null, то критерий не учитывается;
  - type - типы ДО, для которых производится поиск. Можно передавать список значений, разделенных запятой.
- `QueryContext<DocflowPage> getDocflows(QueryContext<?> parent)`  
Должен принимать параметр **QueryContext**, содержащий следующие данные:  
  - признак завершенных ДО. Для установки необходимо использовать метод **setFinish**; 
  - признак включения входящих документов. Для установки необходимо использовать метод **setIncoming**;
  - смещение от начала списка ДО. Для установки необходимо использовать метод **setSkip**;
  - максимальное количество возвращаемых ДО. Для установки необходимо использовать метод **setTake**;
  - ИНН и КПП подотчетной организации. Для установки необходимо использовать метод **setInnKpp**;

Методы возвращают структуру данных **DocflowPage**, содержащую следующие данные:  

- skip - смещение от начала списка ДО;
- take - количество возвращаемых ДО;
- docflows-page-item - список элементов, содержащих описание ДО, и содержащие следующие данные:
	- идентификатор ДО;
	- тип;
	- статус;
	- список ссылок;
	- дата создания;
	- дата обновления.

#### 4.5.2. Методы для поиска ДО по идентификатору

- `CompletableFuture<QueryContext<Docflow>> lookupDocflowAsync(String docflowId)`  
Параметры:  
  - docflowId - идентификатор ДО.
- `QueryContext<Docflow> lookupDocflow(QueryContext<?> cxt)`  
Должен принимать параметр **QueryContext**, содержащий следующие данные:  
  - идентификатор ДО. Для установки необходимо использовать метод **setDocflowId**.  

Методы возвращает структуру данных **Docflow**, содержащую следующие данные
  
- идентификатор ДО;
- тип;
- статус;
- список документов;
- дата создания;
- дата обновления.

#### 4.5.3. Методы получения списка документов ДО

- `CompletableFuture<QueryContext<List<Document>>> getDocumentsAsync(String docflowId)`  
Параметры:
  - docflowId - идентификатор ДО.
- `QueryContext<List<Document>> getDocuments(QueryContext<?> parent)`  
Должен принимать параметр **QueryContext**, содержащий следующие данные:  
  - идентификатор ДО. Для установки необходимо использовать метод **setDocflowId**.  

Методы возвращает список структур данных **Document**, содержащую следующие данные.

#### 4.5.4. Методы получения документа по идентификатору

- `CompletableFuture<QueryContext<Document>> lookupDocumentAsync(String docflowId, String documentId)`
Параметры:
  - docflowId - идентификатор ДО;
  - documentId - идентификатор документа.
- `QueryContext<Document> lookupDocument(QueryContext<?> parent)`  
Должен принимать параметр **QueryContext**, содержащий следующие данные:  
  - идентификатор ДО. Для установки необходимо использовать метод **setDocflowId**;  
  - идентификатор документа. Для установки необходимо использовать метод **setDocumentId**.

Методы возвращает структуру данных **Document**.

#### 4.5.5. Методы получения печатной формы документа

Перед формирование печатной формы сервер проверяет подпись для передаваемого контента документа. Если подпись окажется неверной, сервер вернет ошибку.

- `CompletableFuture<QueryContext<String>> printAsync(String docflowId, String documentId, String documentContentBase64)`
Параметры:
  - docflowId - идентификатор ДО;
  - documentId - идентификатор документа;
  - documentContentBase64 - незашифрованный контент документа в кодировке BASE64. 
- `QueryContext<String> print(QueryContext<?> parent)`  
Должен принимать параметр **QueryContext**, содержащий следующие данные:  
  - идентификатор ДО. Для установки необходимо использовать метод **setDocflowId**;  
  - идентификатор документа. Для установки необходимо использовать метод **setDocumentId**;
  - контент документа в кодировке **BASE64**. Для установки необходимо использовать метод **setContentString**.

Методы возвращает печатную форму в формате **PDF** в кодировке **BASE64**.

#### 4.5.6. Методы получения дескриптора документа

- `CompletableFuture<QueryContext<DocumentDescription>> lookupDescriptionAsync(String docflowId, String documentId)`  
Параметры:
  - docflowId - идентификатор ДО;
  - documentId - идентификатор документа.
- `QueryContext<DocumentDescription> lookupDescription(QueryContext<?> parent)`  
Должен принимать параметр **QueryContext**, содержащий следующие данные:  
  - идентификатор ДО. Для установки необходимо использовать метод **setDocflowId**;  
  - идентификатор документа. Для установки необходимо использовать метод **setDocumentId**.

Методы возвращает структуру данных DocumentDescription, содержащую следующую информацию:

- тип документа;
-  имя файла;
-  тип контента (Content-Type).

#### 4.5.7. Методы получения зашифрованного контента документа

- `CompletableFuture<QueryContext<byte[]>> getEncryptedContentAsync(String docflowId, String documentId)`
Параметры:
  - docflowId - идентификатор ДО;
  - documentId - идентификатор документа.
- `QueryContext<byte[]> getEncryptedContent(QueryContext<?> parent)`  
Должен принимать параметр **QueryContext**, содержащий следующие данные:  
  - идентификатор ДО. Для установки необходимо использовать метод **setDocflowId**;  
  - идентификатор документа. Для установки необходимо использовать метод **setDocumentId**.

Методы возвращает массив байт зашифрованного контента документа.

#### 4.5.8. Методы получения списка подписей для документа

- `CompletableFuture<QueryContext<List<Signature>>> getSignaturesAsync(String docflowId, String documentId)`
Параметры:
  - docflowId - идентификатор ДО;
  - documentId - идентификатор документа.
- `QueryContext<List<Signature>> getSignatures(QueryContext<?> parent)`  
Должен принимать параметр **QueryContext**, содержащий следующие данные:  
  - идентификатор ДО. Для установки необходимо использовать метод **setDocflowId**;  
  - идентификатор документа. Для установки необходимо использовать метод **setDocumentId**.

Методы возвращает список подписей.

#### 4.5.9. Методы получения структуры данных для подписи документа

- `CompletableFuture<QueryContext<Signature>> getSignatureAsync(String docflowId, String documentId, String signatureId)`
Параметры:
  - docflowId - идентификатор ДО;
  - documentId - идентификатор документа;
  - signatureId - идентификатор подписи.
- `QueryContext<Signature> getSignature(QueryContext<?> parent)`  
Должен принимать параметр **QueryContext**, содержащий следующие данные:  
  - идентификатор ДО. Для установки необходимо использовать метод **setDocflowId**;  
  - идентификатор документа. Для установки необходимо использовать метод **setDocumentId**.
  - идентификатор подписи. Для установки необходимо использовать метод **setSignatureId**.

Методы возвращает структуру данных для подписи.

#### 4.5.10. Методы получения контента подписи документа

- `CompletableFuture<QueryContext<byte[]>> getSignatureContentAsync(String docflowId, String documentId, String signatureId)`
Параметры:
  - docflowId - идентификатор ДО;
  - documentId - идентификатор документа;
  - signatureId - идентификатор подписи.
- `QueryContext<byte[]> getSignatureContent(QueryContext<?> parent)`  
Должен принимать параметр **QueryContext**, содержащий следующие данные:  
  - идентификатор ДО. Для установки необходимо использовать метод **setDocflowId**;  
  - идентификатор документа. Для установки необходимо использовать метод **setDocumentId**.
  - идентификатор подписи. Для установки необходимо использовать метод **setSignatureId**.

Методы возвращает массив байт подписи для документа.

#### 4.5.11. Методы для создания ответных документов

- `CompletableFuture<QueryContext<List<DocumentToSend>>> generateRepliesAsync(Docflow docflow, String signerX509Base64)`
Параметры:
  - docflow - объект **Docflow** существующего ДО;
  - signerX509Base64 - сертификат подписи в кодировке BASE64.
- `QueryContext<List<DocumentToSend>> generateReplies(QueryContext<?> parent)`  
Должен принимать параметр **QueryContext**, содержащий следующие данные:  
  - объект **Docflow** существующего ДО. Для установки необходимо использовать метод **setDocflow**.  

Методы возвращает список структуру данных DocumentToSend.

#### 4.5.12. Методы для отправки ответного документа

После создания ответных документов, перед отправкой, необходимо подписать документ и установить подпись в объект **DocumentToSend** с помощью метода **setSignature**. Метод **setSignature** на вход получает объект SignatureToSend, в который, в свою очередь, должна быть установлена подпись в формате PKCS#7 в DER-кодировке, с помощью метода **setContentData**.    

- `CompletableFuture<QueryContext<Docflow>> sendReplyAsync(DocumentToSend documentToSend)`
Параметры:
  - documentToSend - объект **DocumentToSend**, возвращаемый методом "создание ответных документов".
- `QueryContext<Docflow> sendReply(QueryContext<?> parent)`  
Должен принимать параметр **QueryContext**, содержащий следующие данные:  
  - объект **DocumentToSend**. Для установки необходимо использовать метод **setDocumentToSend**.  

Методы возвращает структуру данных Docflow.

### 4.5. Сервис для работы с лентой событий

#### 4.5.1. Методы для постраничного получения списка событий

Все события упорядочены по возрастанию идентификатора события, который представляет из себя монотонно возрастающую функцию по времени наступления события.

- `CompletableFuture<QueryContext<EventsPage>> getEventsAsync(String fromId, int size)`
Параметры:
  - fromId - идентификатор события;
  - size - максимальное количество возвращаемых событий.
- `QueryContext<EventsPage> getEvents(QueryContext<?> cxt)`
Должен принимать параметр **QueryContext**, содержащий следующие данные:  
  - идентификатор события. Для установки необходимо использовать метод **setFromId**;
  - максимальное количество возвращаемых событий. Для установки необходимо использовать метод **setSize**.

Методы возвращают структуру данных **EventsPage** со списком событий **ApiEvent**.

